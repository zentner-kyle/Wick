union ("b", x) ("b", y) = if x == y then ("b", x) else ("o", [x, y]);

union o@("o", oi) ("b", b) |
union ("b", b) o@("o", oi) = if any (b==) oi then o else ("o", b:oi);

// List union as sets.
list_union a::list b::list = a + [x | x = b; ~any (x==) a];

union ("o", x) ("o", y) = ("o", (list_union x y));

same_tag x@("t", x1, x2) y@("t", y1, y2) = x1 == y1;

union x@("t", x1, x2) y@("t", y1, y2) = if x1 == y1 then ("t", x1, (union x2 y2)) else ("o", [x, y]);

modify lst@(x:xs) test func = if (test x) then (func x):xs else x:(modify xs test func);

union t@("t", _) ("o", os) |
union ("o", os) t@("t", _) = ("o", (if any (same_tag t) os
                                    then modify os (same_tag t) (union t)
                                    else t:os));

union t@("t", _) b@("b", _) |
union b@("b", _) t@("t", _) = ("o", [b, t]);

// union_s x@("", xv):xs y@("", yv):ys = if xv == yv then x:(union_s xs ys) else ("", (union xv yv)):(union_s xs ys);

// union_s x@(xk, xv):xs y@("", yv):ys |
// union_s y@("", yv):ys x@(xk, xv):xs = if xv == yv then x:(union_s xs ys) else (xk, (union xv yv)):(union_s xs ys);

assoc_member [] key     = false;
assoc_member (x:xs) key = if x!0 == key then true else assoc_member xs key;

assoc_get []   key     = throw out_of_bounds;
assoc_get (x:xs) key   = if x!0 == key then x!1 else assoc_get xs key;

assoc_remove [] key    = [];
assoc_remove (x:xs) key  = if x!0 == key then xs else x:(assoc_remove xs key);

assoc_join f x [] |
assoc_join f [] x = x;

assoc_join f x@(x1:xs) y@(y1:ys) = if assoc_member x y1!0 then (f (assoc_get x y1!0) y1):(assoc_join f (assoc_remove x y1!0) ys)  else y1:(assoc_join f x ys);

assoc_combine fb fx fy x [] = map fx x; // Recursive base condition.
assoc_combine fb fx fy [] y = map fy y; // Incidental base condition.

assoc_combine fb fx fy x@(x1:xs) y@(y1:ys) = if assoc_member x y1!0
                                             then (fb (assoc_get x y1!0) y1):(assoc_combine fb fx fy (assoc_remove x y1!0) ys)
                                             else (fy y1):(assoc_combine fb fx fy x ys);

assoc_join f x y = assoc_combine f id id x y;

union [] []      = [];

// union_assoc x@(x1:xs) y@(y1:ys) = 
                                  // [(k, v) | k = map (!0) x; ]

// union x@("s", xs, kxs) y@("s", ys, yks)   = if x == y then x else ("s", (zipwith union xs ys), 
                                              // xs == ys then x else 

using system;
print_union a b = printf "%s" ("union (" + (str a) + ") (" + (str b) + ") = (" + (str $ union a b) + ")\n");
print_union ("b", "i") ("b", "i");
print_union ("b", "i") ("b", "f");
print_union ("b", "i") ("b", "v");
print_union ("o", ["i", "f"]) ("b", "i");
print_union ("o", ["i", "f"]) ("b", "v");
print_union ("o", ["i", "f"]) ("o", ["i", "v"]);
print_union ("t", "Tag1", []) ("b", "i");
print_union ("t", "Tag1", []) ("b", "i");
print_union ("t", "Tag1", []) ("t", "Tag1", []);

// List intersection as sets.
list_intersect a::list b::list = [x | x = a; any (x==) b];

