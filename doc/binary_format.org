* Main goals:

** Position independent, able to be serialized or transmitted easily
*** That means no pointers, and all plain old data.

** Fast and compact for simple types
   We need super lightweight type dispatch for use in angel-stage.
   As in 32 bits might be a little excessive.

** Supporting random type ids (128 or 256 bit).
*** So we need dynamic sized type ids


* Decisions:

** VarInts (Prototype Buffers, SmileFormat) vs. first byte (EBML, UTF-8)


* Design

  Contain both typed and non-typed information.
  + Spec should indicate multiple ways of storing types.
    + In external prototype files
    + In the object header
    + In the collection object holding the current object.

  To determine type on a typed message:
  + If the top bit isn't set, we have a one-byte encoded core type.
    + The values 0x00 and 0xFF are both illegal to help in locating corrupt / incorrect data.
    + Core values include: standard sized ints and floats
    + Various string types
    + Arrays
    + Consistently typed mappings / tables?
  + If the top bit is set, then the value in the lower 5 bits is the power of two + 1 number of bytes in the type id.
    + The sixth bit is reserved although this scheme allows such massive ID's that it should need to be used.
    + The seventh bit must not be set, since that would make the byte 0xFF, the first byte of small negative values.
  + Type ID Classes:
    + Illegal : 0000 0000, 1111 1111
    + Core    : 0xxx xxxx - Reserved for core types
    + Extended: 10xx xxxx  xxxx xxxx - Extended, reserved types
    + Class A0: 110x xxxx  xxxx xxxx  xxxx xxxx  xxxx xxxx - Per application types, total tag fits in 32 bits.
    + Class A1: 1110 xxxx  xxxx xxxx  xxxx xxxx  xxxx xxxx  xxxx xxxx  xxxx xxxx xxxx xxxx  xxxx xxxx  xxxx xxxx  xxxx xxxx - 64 Bit ID
    + Class A2: 1111 0000  0000 0000  [xxxx xxxx] * 16 - 128 Bit ID
    + Class A3: 1111 1000  0000 0000  [xxxx xxxx] * 32 - 256 Bit ID
    + Reserved: 1111 xxxx  xxxx xxxx
  + Core types
    + 0xxx xxxx
    + 0000 0001 1 byte uint
    + 0000 0010 2 byte uint
    + 0000 0011 4 byte uint
    + 0000 0100 8 byte uint
    + 0000 0101 16 byte uint

    + 0000 0110 Reserved

    + 0000 0111 1 byte sint
    + 0000 1000 2 byte sint
    + 0000 1001 4 byte sint
    + 0000 1010 8 byte sint
    + 0000 1011 16 byte sint

    + 0000 1100 2 byte float
    + 0000 1101 4 byte float
    + 0000 1110 8 byte float
    + 0000 1111 16 byte float

    + 0001 0000 UTF-8  Encoded String
    + 0001 0001 UTF-16 Encoded String NOT SUPPORTED
    + 0001 0010 UTF-32 Encoded String NOT SUPPORTED
    + 0001 0011 Reserved

    + 0001 0100 Array
    + 0001 0101 Array firm typed

    + 0001 0110 Associative Array
    + 0001 0111 Associative Array firm typed

    + 0001 1000 UTF-8  Encoded String Iterator
    + 0001 1001 UTF-16 Encoded String Iterator NOT SUPPORTED
    + 0001 1010 UTF-32 Encoded String Iterator NOT SUPPORTED
    + 0001 1011 Reserved

    + 0001 1100 Array Iterator
    + 0001 1101 Array (Firm Typed) Iterator
    + 0001 1110 Associative Array Iterator
    + 0001 1111 Associative Array (Firm Typed) Iterator

    + 0010 0000 ID
    + 0010 0001 Error
    + 0010 0010 Continuation
    + 0010 0011 Type
    + 0010 0100 Thread
    + 0011 xxxx Interpreted Function
    + 0011 0000 Interpreted Function Bytecode Version 0

    + 0100 xxxx RAM Only objects

    + 0100 0000 Dynamically typed pointer
    + 0100 0001 C Function * (void * -> wick_error)

    + 01xx xxxx Reserved

  + Extended:
    + 1000 0000 0000 xxxx Reserved for parser
    + 1000 0000 0000 0000 Whitespace match
    + 1000 0000 0000 0001 Precise string match
    + 1000 0000 0000 0010 Function matcher
    + 1000 0000 0000 0100 C Function * (wick_string * in, wick_string * out) -> wick_error
    + 1000 0000 0000 1000 Option combinator
    + 1000 0000 0000 1001 Sequence combinator


* Other binary formats:
  
** EBML

*** Originally from Matroska project
*** Big endian

*** Element IDs, bits in big endian:
  + Class A: 1xxx xxxx
  + Class B: 01xx xxxx  xxxx xxxx
  + Class C: 001x xxxx  xxxx xxxx  xxxx xxxx
  + Class D: 0001 xxxx  xxxx xxxx  xxxx xxxx  xxxxx xxxx
  - All 1's are reserved

*** Data sizes:
  + 1xxx xxxx
  + 01xx xxxx  xxxx xxxx
  + 001x xxxx  xxxx xxxx  xxxx xxxx
  + 0001 xxxx  xxxx xxxx  xxxx xxxx  xxxx xxxx
  + 0000 1xxx  xxxx xxxx  xxxx xxxx  xxxx xxxx  xxxx xxxx
  + 0000 01xx  xxxx xxxx  xxxx xxxx  xxxx xxxx  xxxx xxxx  xxxx xxxx
  + 0000 001x  xxxx xxxx  xxxx xxxx  xxxx xxxx  xxxx xxxx  xxxx xxxx  xxxx xxxx
  + 0000 0001  xxxx xxxx  xxxx xxxx  xxxx xxxx  xxxx xxxx  xxxx xxxx  xxxx xxxx  xxxx xxxx
  + 1111 Unknown / Dynamic

*** Data:
  + Integers are dynamically sized using data size above, but not internally
    + In other words, integers are always as they would normally
      appear in big endian, with redundant 0x00 and 0xFF's trimmed out
      + -2 = 0xFFFFFFFFFFFFFE or 0xFFFE or 0xFE etc.
      +  5 = 0x000000000005 or 0x0005 or 0x05 etc.

*** Important ideas:
  + CRC-32 as a "global elements"
    + Each one can confirm that a small part of the data is intact,
      and they're all incorporated into the whole document's CRC check
  + Void signature used to mark data as unfilled

*** Document design:
  | Element Name         | Level | Class-ID         | Mandatory | Multiple | Range | Default | Element Type | Description                                                                                                                                                                                                                                                                                     |       |                                                                                                      |
  | EBML                 |     0 | [1A][45][DF][A3] | *         | *        | -     | -       | sub-elements | Set the EBML characteristics of the data to follow. Each EBML document has to start with this.                                                                                                                                                                                                  |       |                                                                                                      |
  | EBMLVersion          |     1 | [42][86]         | *         | -        | -     | 1       | u-integer    | The version of EBML parser used to create the file.                                                                                                                                                                                                                                             |       |                                                                                                      |
  | EBMLReadVersion      |     1 | [42][F7]         | *         | -        | -     | 1       | u-integer    | The minimum EBML version a parser has to support to read this file.                                                                                                                                                                                                                             |       |                                                                                                      |
  | EBMLMaxIDLength      |     1 | [42][F2]         | *         | -        | -     | 4       | u-integer    | The maximum length of the IDs you'll find in this file (4 or less in Matroska).                                                                                                                                                                                                                 |       |                                                                                                      |
  | EBMLMaxSizeLength    |     1 | [42][F3]         | *         | -        | -     | 8       | u-integer    | The maximum length of the sizes you'll find in this file (8 or less in Matroska). This does not override the element size indicated at the beginning of an element. Elements that have an indicated size which is larger than what is allowed by EBMLMaxSizeLength shall be considered invalid. |       |                                                                                                      |
  | DocType              |     1 | [42][82]         | *         | -        | -     | -       | string       | A string that describes the type of document that follows this EBML header ('matroska' in our case).                                                                                                                                                                                            |       |                                                                                                      |
  | DocTypeVersion       |     1 | [42][87]         | *         | -        | -     | 1       | u-integer    | The version of DocType interpreter used to create the file.                                                                                                                                                                                                                                     |       |                                                                                                      |
  | DocTypeReadVersion   |     1 | [42][85]         | *         | -        | -     | 1       | u-integer    | The minimum DocType version an interpreter has to support to read this file.                                                                                                                                                                                                                    |       |                                                                                                      |
  | CRC-32               |    1+ | [BF]             | -         | -        | -     | -       | binary       | The CRC is computed on all the data from the last CRC element (or start of the upper level element), up to the CRC element, including other previous CRC elements. All level 1 elements should include a CRC-32.                                                                                |       |                                                                                                      |
  | Void                 |    1+ | [EC]             | -         | -        | -     | -       | binary       | Used to void damaged data, to avoid unexpected behaviors when using damaged data. The content is discarded. Also used to reserve space in a sub-element for later use.                                                                                                                          |       |                                                                                                      |
  | SignatureSlot        |    1+ | [1B][53][86][67] | -         | *        | -     | -       | sub-elements | Contain signature of some (coming) elements in the stream.                                                                                                                                                                                                                                      |       |                                                                                                      |
  | SignatureAlgo        |    2+ | [7E][8A]         | -         | -        | -     | -       | u-integer    | Signature algorithm used (1=RSA, 2=elliptic).                                                                                                                                                                                                                                                   |       |                                                                                                      |
  | SignatureHash        |    2+ | [7E][9A]         | -         | -        | -     | -       | u-integer    | Hash algorithm used (1=SHA1-160, 2=MD5).                                                                                                                                                                                                                                                        |       |                                                                                                      |
  | SignaturePublicKey   |    2+ | [7E][A5]         | -         | -        | -     | -       | binary       | The public key to use with the algorithm (in the case of a PKI-based signature).                                                                                                                                                                                                                |       |                                                                                                      |
  | Signature            |    2+ | [7E][B5]         | -         | -        | -     | -       | binary       | The signature of the data (until a new.                                                                                                                                                                                                                                                         |       |                                                                                                      |
  | SignatureElements    |    2+ | [7E][5B]         | -         | -        | -     | -       | sub-elements | Contains elements that will be used to compute the signature.                                                                                                                                                                                                                                   |       |                                                                                                      |
  | SignatureElementList |    3+ | [7E][7B]         | -         | *        | -     | -       | sub-elements | A list consists of a number of consecutive elements that represent one case where data is used in signature. Ex: Cluster                                                                                                                                                                        | Block | BlockAdditional means that the BlockAdditional of all Blocks in all Clusters is used for encryption. |
  | SignedElement        |    4+ | [65][32]         | -         | *        | -     | -       | binary       | An element ID whose data will be used to compute the signature.                                                                                                                                                                                                                                 |       |                                                                                                      |


** UTF-8

*** Text only, obviously.

*** "Big Endian" in theory, but not numerical.

*** Dynamically sized encoding of Unicode code points.
   UCS-4 range (hex.)           UTF-8 octet sequence (binary)
   0000 0000-0000 007F   0xxxxxxx
   0000 0080-0000 07FF   110xxxxx 10xxxxxx
   0000 0800-0000 FFFF   1110xxxx 10xxxxxx 10xxxxxx

   0001 0000-001F FFFF   11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
   0020 0000-03FF FFFF   111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx
   0400 0000-7FFF FFFF   1111110x 10xxxxxx ... 10xxxxxx


** BJSON

*** Little endian.

*** Extremely simple, without any capabilities above JSON besides the ability to hold unknown, unspecified binary data.

*** Basically one byte type tag, followed by a either a fixed size number or variable length container based on that tag.

*** Specification text:
    Size fields contain number of bytes.

    primitive values:
    There are "zero" values, one byte sized:
    0 - null
    1 - numeric zero, or boolean false
    2 - empty string
    3 - boolean true (may be also a numeric one)

    positive_integer:
    4, uint8
    5, uint16
    6, uint32
    7, uint64

    negative_integer:
    they are in positive form, not mod2
    8, uint8
    9, uint16
    10, uint32
    11, uint64

    float:
    12, 32bit float
    13, 64bit float (double)

    utf8_string: default coding is utf-8 the string MUST NOT have
    null-termination code string cannot have any "zero" bytes to avoid
    null-termination finishing the string before its real length

    16, size[uint8], utf8_data[size*byte] - a short string up to 255 bytes
    17, size[uint16], utf8_data[size*byte] - a string of up to 64k bytes
    18, size[uint32], utf8_data[size*byte] - a long string, 64K to 4GB
    19, size[uint64], utf8_data[size*byte] - a very long string, which
    probably won't be even used for now

    binary:
    binary data of specified length.
    This is not fully JSON transcodable, as the JSON has no native
    support for binary data.

    20, size[uint8], binary_data[size*byte]
    21, size[uint16], binary_data[size*byte]
    22, size[uint32], binary_data[size*byte]
    23, size[uint64], binary_data[size*byte]

    array:
    in JSON represented as array [item0, item1, item2, ...]

    32, size[uint8], item0, item1, item2, ...
    33, size[uint16], item0, item1, item2, ...
    34, size[uint32], item0, item1, item2, ...
    35, size[uint64], item0, item1, item2, ...

    map of key -> value:
    in JSON represented as object {key0:value0, key1:value1, ...}

    For JSON compatibility keys shall be utf8_string.  However
    implementation may ignore that (use any other type as keys, even
    mixing types) if the JSON-compatibility is not a requirement.

    Keys should be unique.

    36, size[uint8], key0, value0, key1, value1, ...
    37, size[uint16], key0, value0, key1, value1, ...
    38, size[uint32], key0, value0, key1, value1, ...
    39, size[uint64], key0, value0, key1, value1, ...


** BSON

*** Originally from MongoDB

*** Little endian.

*** Libraries in several languages.
*** Version 1.0
     BSON is a binary format in which zero or more key/value pairs are
     stored as a single entity. We call this entity a document.  The
     following grammar specifies version 1.0 of the BSON standard. We've
     written the grammar using a pseudo-BNF syntax. Valid BSON data is
     represented by the document non-terminal.
**** Basic Types
     The following basic types are used as terminals in the rest of
     the grammar. Each type must be serialized in little-endian
     format.
     | byte   | 1 byte (8-bits)                          |
     | int32  | 4 bytes (32-bit signed integer)          |
     | int64  | 8 bytes (64-bit signed integer)          |
     | double | 8 bytes (64-bit IEEE 754 floating point) |
**** Non-terminals
     The following specifies the rest of the BSON grammar. Note that
     quoted strings represent terminals, and should be interpreted
     with C semantics (e.g. "\x01" represents the byte 0000
     0001). Also note that we use the * operator as shorthand for
     repetition (e.g. ("\x01"*2) is "\x01\x01"). When used as a unary
     operator, * means that the repetition can occur 0 or more times.

     document  ::=  int32 e_list "\x00"	BSON Document
     e_list    ::=  element e_list	Sequence of elements
                     or ""
     element   ::=  "\x01" e_name double             Floating point
                 |  "\x02" e_name string             UTF-8 string
                 |  "\x03" e_name document           Embedded document
                 |  "\x04" e_name document           Array
                 |  "\x05" e_name binary             Binary data
                 |  "\x06" e_name Undefined          Deprecated
                 |  "\x07" e_name (byte*12)          ObjectId
                 |  "\x08" e_name "\x00"             Boolean "false"
                 |  "\x08" e_name "\x01"             Boolean "true"
                 |  "\x09" e_name int64              UTC datetime
                 |  "\x0A" e_name                    Null value
                 |  "\x0B" e_name cstring cstring    Regular expression
                 |  "\x0C" e_name string (byte*12)   DBPointer — Deprecated
                 |  "\x0D" e_name string             JavaScript code
                 |  "\x0E" e_name string             Symbol — Deprecated
                 |  "\x0F" e_name code_w_s           JavaScript code w/ scope
                 |  "\x10" e_name int32              32-bit Integer
                 |  "\x11" e_name int64              Timestamp
                 |  "\x12" e_name int64              64-bit integer
                 |  "\xFF" e_name                    Min key
                 |  "\x7F" e_name                    Max key
     e_name    ::=    cstring                        Key name
     string    ::=    int32 (byte*) "\x00"           String
     cstring   ::=    (byte*) "\x00"                 CString
     binary    ::=    int32 subtype (byte*)          Binary
     subtype   ::=    "\x00"                         Binary / Generic
                 |    "\x01"                         Function
                 |    "\x02"                         Binary (Old)
                 |    "\x03"                         UUID (Old)
                 |    "\x04"                         UUID
                 |    "\x05"                         MD5
                 |    "\x80"                         User defined
     code_w_s  ::=    int32 string document          Code w/ scope


** SmileFormat

*** "JSON-compatible" in that it runs off the same Java encoding & decoding library.


*** Rather complex specification:
**** MIME Type

     There is no formal or official MIME type registered for Smile
     content, but the current best practice (as of July 2011) is to
     use:

     application/x-jackson-smile

     since this is used by multiple existing projects.

**** High-level format

     At high level, content encoded using this format consists of a
     simple sequence of sections, each of which consists of:

     A 4-byte header (described below) that can be used to identify
     content that uses the format, as well as its version and any
     per-section configuration settings there may be.  Sequence (0 to
     N) of tokens that are properly nested (all
     start-object/start-array tokens are matched with equivalent close
     tokens) within sequence.  Optional end marker, 0xFF, can be used:
     if encountered, it will be consider same as end-of-stream. This
     is added as a convenience feature to help with framing.  Header
     consists of:

     - Constant byte #0: 0x3A (ASCII ':')
     - Constant byte #1: 0x29 (ASCII ')')
     - Constant byte #2: 0x0A (ASCII linefeed, '\n')
     - Variable byte #3, consisting of bits:
       - Bits 4-7 (4 MSB): 4-bit version number; 0x00 for current
         version (note: it is possible that some bits may be reused if
         necessary)
       - Bits 3: Reserved
       - Bit 2 (mask 0x04) Whether raw binary (unescaped 8-bit) values
         may be present in content
       - Bit 1 (mask 0x02): Whether shared String value checking was
         enabled during encoding -- if header missing, default value
         of "false" must be assumed for decoding (meaning parser need
         not store decoded String values for back referencing)
       - Bit 0 (mask 0x01): Whether shared property name checking was
         enabled during encoding -- if header missing, default value
         of "true" must be assumed for decoding (meaning parser MUST
         store seen property names for possible back references)

     And basically first 2 bytes form simple smiley and 3rd byte is a
     (Unix) linefeed: this to make command-line-tool based
     identification simple: choice of bytes is not significant beyond
     visual appearance. Fourth byte contains minimal versioning marker
     and additional configuration bits.

**** Low-level Format

     Each section described above consist of set of tokens that forms
     properly nested JSON value. Tokens are used in two basic modes:
     value mode (in which tokens are "value tokens"), and
     property-name mode ("key tokens"). Property-name mode is used
     within JSON Object values to denote property names, and
     alternates between name / value tokens.

     Token lengths vary from a single byte (most common) to 9
     bytes. In each case, first byte determines type, and additional
     bytes are used if and as indicated by the type byte. Type byte
     value ranges overlap between value and key tokens; but not all
     type bytes are legal in both modes.

     Use of certain byte values is limited:

     - Values 0xFD through 0xFF are not used as token type markers,
       key markers, or in values; with exception of optional raw
       binary data (which can contain any values). Instead they are
       used to:
       - 0xFF can be used as logical data end marker; this use is
         intended to be compatible with Web Sockets usage
       - 0xFE is reserved for future use, and not used for anything
         currently.
       - 0XFD is used as type marker for raw binary data, to allow for
         uniquely identifying raw binary data sections (note too that
         content header will have to explicitly enable support;
         without this content can not contain raw binary data
         sections)
       - 0xFC is used as String end-marker (similar to use of zero
         byte with C strings) for long Strings that do not use length
         prefix.
       - Since number encodings never use values 0xC0 - 0xFF, and
         UTF-8 does not use values 0xF8 - 0xFF, these are only uses
         within Smile format (except for possible raw binary data)
     - Values 0xF8 - 0xFB are only used for type tokens START_ARRAY,
       END_ARRAY, START_OBJECT and END_OBJECT (respectively); they are
       not used for String or numeric values of field names and can
       otherwise only occur in raw binary data sections.
     - Value 0x00 has no specific handling (can occur in variable
       length numeric values, as UTF-8 null characters and so on).
     - 0x3A is not used as type byte in either mode, since it is the
       first byte of 4-byte header sequence, and may thus be
       encountered after value tokens (and although it can not occur
       within key mode, it is reserved to increase chances of
       detecting corrupted content)
       - Value can occur within many kinds of values (vints, String
         values)

***** Tokens: general

      Some general notes on tokens:

      - Strings are encoded using standard UTF-8 encoding; length is
        indicated either by using:
        - 6-bit byte length prefix, for lengths 1 - 63 (0 is not used
          since there is separate token)
        - End-of-String marker byte (0xFE) for variable length
          Strings.
      - Integral numeric values up to Java long (64-bit) are handled
        using ZigZag-encoded VInts (see Appendix for details):
        - sequence of 1 to 10 bytes that can represent all 64-bit
          numbers.
        - VInts are big endian, meaning that most-significant bytes
          come first
        - All bytes except for the last one have their MSB clear,
          leaving 7 data bits
        - Last byte has its MSB (bit #7) set, but bit #6 NOT set (to
          avoid possibility of collision with 0xFF), leaving 6 data
          bits.
        - This means that 2 byte VInt has 13 data bits, for example;
          and minimum number of bytes to represent a Java long (64
          bits) is 10; 9 bytes would give 62 bits (8 * 7 + 6).
        - Signed VInt values are handled using "zigzag" encoding,
          where sign bit is shifted to be the least-significant bit,
          and value is shifted left by one (i.e. multiply by one).
        - Unsigned VInts used as length indicators do NOT use zigzag
          encoding (since it is only needed to help with encoding of
          negative values)
      - Length indicators are done using VInts (for binary data,
        unlimited length ("big") integer/decimal values)
        - All length indicators define _actual_ length of data; not
          possibly encoded length (in case of "safe" encoding, encoded
          data is longer, and that length can be calculated from
          payload data length)
      - Floating point values (IEEE 32 and 64-bit) are encoded using
        fixed-length big-endian encoding (7 bits used to avoid use of
        reserved bytes like 0xFF):
        - Data is "right-aligned", meaning padding is prepended to the
          first byte (and its MSB).
      - "Big" decimal/integer values use "safe" binary encoding
      - "Safe" binary encoding simply uses 7 LSB: data is left aligned
        (i.e. any padding of the last byte is in its rightmost,
        least-significant, bits).

***** Tokens: value mode

     Value is the default mode for tokens for main-level ("root")
     output context and JSON Array context. It is also used between
     JSON Object property name tokens (see next section).

     Conceptually tokens are divided in 8 classes, class defined by 3
     MSB of the first byte:

     - 0x00 - 0x1F: Short Shared Value String reference (single byte)
     - 0x20 - 0x3F: Simple literals, numbers
     - 0x40 - 0x5F: Tiny ASCII (1 - 32 bytes == chars)
     - 0x60 - 0x7F: Short ASCII (33 - 64 bytes == chars)
     - 0x80 - 0x9F: Tiny Unicode (2 - 33 bytes; <= 33 characters)
     - 0xA0 - 0xBF: Short Unicode (34 - 64 bytes; <= 64 characters)
     - 0xC0 - 0xDF: Small integers (single byte)
     - 0xE0 - 0xFF: Binary / Long text / structure markers (0xF0 -
       0xF7 is unused, reserved for future use -- but note, used in
       key mode)

     These token class are are described below.

***** Token class: Short Shared Value String reference

      Prefix: 0x00; covers byte values 0x01 - 0x1F (0x00 not used as value type token)

      5 LSB used to get reference value of 1 - 31; 0 is not used with
      this version (reserved for future use) Back reference resolved
      as explained in section 4.

***** Token class: Simple literals, numbers

      Prefix: 0x20; covers byte values 0x20 - 0x3F, although not all
      values are used

      - Literals (simple, non-structured)
        - 0x20: "" (empty String)
        -  0x21: null
        - 0x22 / 0x23: false / true
      - Numbers:
        - 0x24 - 0x27 Integral numbers; 2 LSB (0x03) contain subtype
        - 0x0 - 32-bit integer; zigzag encoded, 1 - 5 data bytes
        - 0x1 - 64-bit integer; zigzag encoded, 5 - 10 data bytes
        - 0x2 - BigInteger
      - Encoded as token indicator followed by 7-bit escaped binary
        (with Unsigned VInt (no-zigzag encoding) as length indicator)
        that represent magnitude value (byte array)
        - 0x3 - reserved for future use
        - 0x28 - 0x2B floating point numbers
      2 LSB (0x03) contain subtype
        - 0x00: 32-bit float
        - 0x01: 64-bit double
        - 0x02: BigDecimal
      - Encoded as token indicator followed by zigzag encoded scale
        (32-bit), followed by 7-bit escaped binary (with Unsigned VInt
        (no-zigzag encoding) as length indicator) that represent
        magnitude value (byte array) of integral part.
        - 0x3 - reserved for future use
      - Reserved for future use, avoided
        - 0x2C - 0x2F reserved for future use (non-overlapping with
          keys)
        - 0x30 - 0x3F overlapping with key mode and/or header (0x3A)
      Rest of the possible values are reserved for future use and not
      used currently.

***** Token classes: Tiny ASCII, Small ASCII

      Prefixes: 0x40 / 0x60; covers all byte values between 0x40 and 0x7F.

       - 0x40 - 0x5F: Tiny ASCII
         - String with specified length; all bytes in ASCII range.
         - 5 LSB used to indicate lengths from 1 to 32 (bytes == chars)
       - 0x60 - 0x7F: Small ASCII
         - String with specified length; all bytes in ASCII range
         - 5 LSB used to indicate lengths from 33 to 64 (bytes == chars)

***** Token classes: Tiny Unicode, Small Unicode

      Prefixes: 0x80 / 0xA0; covers all byte values between 0x80 and
      0xBF; except that 0x80 is not encodable (since there is no 1
      byte long multi-byte-character String)

        - 0x80 - 0x9F
          - String with specified length; bytes NOT guaranteed to be
            in ASCII range
          - 5 LSB used to indicate _byte_ lengths from 2 to 33 (with
            character length possibly less due to multi-byte
            characters)
          - Length 1 can not be expressed, since only ASCII characters
            have single byte encoding (which means it should be
            encoded with "Tiny ASCII")
        - 0xA0 - 0xBF
          - 5 LSB used to indicate _byte_ lengths from 34 to 65 (with
            character length possibly less due to multi-byte
            characters)

***** Token class: Small integers

      Prefix: 0xC0; covers byte values 0xC0 - 0xDF, all values used.

      Zigzag encoded
      5 LSB used to get values from -16 to +15

***** Token class: Misc; binary / text / structure markers

      Prefix: 0xE0; covers byte values 0xE0 - 0xEF, 0xF8 - 0xFF:
      0xF8 - 0xFF not used with this format version (reserved for
      future use)

      Note, too, that value 0x36 could be viewed as "real" END_OBJECT;
      but is not included here since it is only encountered in "key
      mode" (where you either get a key name, or END_OBJECT marker)

      This class is further divided in 8 sub-section, using value of
      bits #2, #3 and #4 (0x1C) as follows:

      - 0xE0: Long (variable length) ASCII text
        - 2 LSB (0x03): reserved for future use
      - 0xE4: Long (variable length) Unicode text
        - 2 LSB (0x03): reserved for future use
      - 0xE8: Shared String reference, long
        - 2 LSB (0x03): used as 2 MSB of index
        - followed by byte used as 8 LSB of index
        - Resulting 10-bit index used as is; values 0-30 are not to be
          used (instead, short reference must be used)
        - Back references are ONLY made to "short" and "tiny"
          Ascii/Unicode Strings, so generator and parser only need to
          keep track of such Strings (but all of them!)
      - 0xEC: Binary, 7-bit encoded
        - 2 LSB (0x03): reserved for future use
        - followed by VInt length indicator, then data in 7/8 encoding
          (only 7 LSB of each byte used; 8 such bytes are used to
          encode 7 "raw" bytes)
      - 0xF0 - 0xF7: not used, reserved for future use (NOTE: used in
        key mode)
      - 0xF8 - 0xFB: Structural markers
      - 0xF8: START_ARRAY
      - 0xF9: END_ARRAY
      - 0xFA: START_OBJECT
      - 0xFB: reserved in token mode (but is END_OBJECT in key mode)
        - this just because object end marker comes as alternative to
          property name.
      - 0xFC: Used as end-of-String marker
      - 0xFD: Binary (raw)
        - followed by VInt length indicator, then raw data
      - 0xFE: reserved for future use
      - 0xFF: end-of-content marker (not used in content itself)

***** Tokens: key mode

      Key mode tokens are only used within JSON Object values; if so,
      they alternate between value tokens (first a key token; followed
      by either single-value value token or multi-token JSON
      Object/Array value). A single token denotes end of JSON Object
      value; all the other tokens are used for expressing JSON Object
      property name.

      Most tokens are single byte: exceptions are 2-byte "long shared
      String" token, and variable-length "long Unicode String" tokens.

      Byte ranges are divides in 4 main sections (64 byte values
      each):

      - 0x00 - 0x3F: miscellaneous
        - 0x00 - 0x1F: not used, reserved for future versions
        - 0x20: Special constant name "" (empty String)
        - 0x21 - 0x2F: reserved for future use (unused for now to
          reduce overlap between values)
        - 0x30 - 0x33: "Long" shared key name reference (2 byte
          token); 2 LSBs of the first byte are used as 2 MSB of 10-bit
          reference (up to 1024) values to a shared name: second byte
          used for 8 LSB.
        - Note: combined values of 0 through 63 are reserved (since
          there is more optimal representation) -- encoder is not to
          produce these values, and decoder should check that these
          are not encountered. Future format versions may choose to
          use these for specific use.
        - 0x34: Long (not-yet-shared) Unicode name. Variable-length
          String; token byte is followed by 64 or more bytes, followed
          by end-of-String marker byte.
        - Note: encoding of Strings shorter than 64 bytes is NOT
          allowed: if such sequence is detected it will constitute an
          error
        - 0x35 - 0x39: not used, reserved for future versions
        - 0x3A: Not used; would be part of header sequence (which is
          NOT allowed in key mode!)
        - 0x3B - 0x3F: not used, reserved for future versions
      - 0x40 - 0x7F: "Short" shared key name reference; names 0
        through 63.
      - 0x80 - 0xBF: Short Ascii names
        - 0x80 - 0xBF: names consisting of 1 - 64 bytes, all of which
          represent UTF-8 Ascii characters (MSB not set) -- special
          case to potentially allow faster decoding
      - 0xC0 - 0xF7: Short Unicode names
        - 0xC0 - 0xF7: names consisting of 2 - 57 bytes that can
          potentially contain UTF-8 multi-byte sequences: encoders are
          NOT required to guarantee there is one, but for efficiency
          reasons are strongly recommended to check.
      - 0xF8 - 0xFA: reserved (avoid overlap with START/END_ARRAY,
        START_OBJECT)
      - 0xFB: END_OBJECT marker
      - 0xFC - 0xFF: reserved for framing, not used in key mode (used
        in value mode)


****  Resolved Shared String references

      Shared Strings refer to already encoded/decoded key names or
      value strings. The method used for indicating which of "already
      seen" String values to use is designed to allow for:

      Efficient encoding AND decoding (without necessarily favoring
      either) To allow keeping only limited amount of buffering (of
      already handled names) by both encoder and decoder; this is
      especially beneficial to avoid unnecessary overhead for cases
      where there are few back references (mostly or completely unique
      values) Mechanism for resolving value string references differs
      from that used for key name references, so two are explained
      separately below.

***** Shared value Strings

      Support for shared value Strings is optional, in that generator
      can choose to either check for shareable value Strings or omit
      the checks. Format header will indicate which option generator
      chose: if header is missing, default value of "false" (no checks
      done for shared value Strings; no back-references exist in
      encoded content) must be assumed.

      One basic limitation is the encoded byte length of a String
      value that can be referenced is 64 bytes or less. Longer Strings
      can not be referenced. This is done as a performance
      optimization, as longer Strings are less likely to be shareable;
      and also because equality checks for longer Strings are most
      costly. As a result, parser only should keep references for
      eligible Strings during parsing.

      Reference length allowed by format is 10 bits, which means that
      encoder can replace references to most recent 1024 potentially
      shareable (referenceable) value Strings.

      For both encoding (writing) and decoding (parsing), same basic
      sliding-window algorithm is used: when a potentially eligible
      String value is to be written, generator can check whether it
      has already written such a String, and has retained
      reference. If so, reference value (between 0 and 1023) can be
      written instead of String value. If no such String has been
      written (as per generator's knowledge -- it is not required to
      even check this), value is to be written. If its encoded length
      indicates that it is indeeed shareable (which can not be known
      before writing, as check is based on byte length, not character
      length!), decoder is to add value into its shareable String
      buffer -- as long as buffer size does not exceed that of 1024
      values. If it already has 1024 values, it MUST clear out buffer
      and start from first entry. This means that reference values are
      NOT relative back references, but rather offsets from beginning
      of reference buffer.

      Similarly, parser has to keep track of decoded short (byte
      length <= 64 bytes) Strings seen so far, and have buffer of up
      to 1024 such values; clearing out buffer when it fills is done
      same way as during content generation. Any shared string value
      references are resolved against this buffer.

      Note: when a shared String is written or parsed, no entry is
      added to the shared value buffer (since one must already be in
      it)

***** Shared key name Strings

      Support for shared property names is optional, in that generator
      can choose to either check for shareable property names or omit
      the checks. Format header will indicate which option generator
      chose: if header is missing, default value of "trues" (checking
      done for shared property names is made, and encoded content MAY
      contain back-references to share names) must be assumed.

      Shared key resolution is done same way as shared String value
      resolution, but buffers used are separate. Buffer sizes are
      same, 1024.



** Google's Prototype Buffers

*** Little endian.

*** VarInts:

    Each byte in a varint, except the last byte, has the most
    significant bit (msb) set – this indicates that there are further
    bytes to come. The lower 7 bits of each byte are used to store the
    two's complement representation of the number in groups of 7 bits,
    least significant group first.

*** Uses external type definitions (.proto files) and compiles those into a parser.

**** Currently supports C++, Java, and Python.

*** Example:

message Person {
  required string name = 1;
  required int32 id = 2;
  optional string email = 3;

  enum PhoneType {
    MOBILE = 0;
    HOME = 1;
    WORK = 2;
  }

  message PhoneNumber {
    required string number = 1;
    optional PhoneType type = 2 [default = HOME];
  }

  repeated PhoneNumber phone = 4;
}

*** Doesn't encode all type information ("Protocol Buffers do not
    contain descriptions of their own types.")

**** Also not "self-delimiting."

*** Designed to allow unknown data to be stored and passed, but has no
    official method for recognizing whether data is of a particular
    type.

**** Although the documentation does recommend using an optional field for each type.

*** Does handle newer streams being fed to old binaries through the
    use of "optional" and "repeated" fields, but cannot deal with the
    removal of "required" fields.


** Apache Thrift

*** Designed to be extremely cross-language.

*** Uses compilation design similar to Prototype Buffers but with a language called Inderface Description Language (IDL).

*** Doesn't support later modification / backwards compatibility as in Prototype Buffers.

*** Has good library support, but appears to have no other obvious advantages over Prototype Buffers.


* Other text formats:

** XML

*** Extensible.

*** Often used with schemas.

*** <tag> based.

*** Ubiquitous

*** Slow to parse and very verbose.


** JSON

*** Most basic here, has no concept of identity or extensibility.

*** Full specification:
  + object
    {}
    { members }
  + members
    pair
    pair , members
  + pair
    string : value
  + array
    []
    [ elements ]
  + elements
    value
    value , elements
  + value
    string
    number
    object
    array
    true
    false
    null
  + string
    ""
    " chars "
  + chars
    char
    char chars
  + char
    any-Unicode-character-
        except-"-or-\-or-
        control-character
    \"
    \\
    \/
    \b
    \f
    \n
    \r
    \t
    \u four-hex-digits
  + number
    int
    int frac
    int exp
    int frac exp
    int
    digit
    digit1-9 digits
    - digit
    - digit1-9 digits
  + frac
    . digits
  + exp
    e digits
  + digits
    digit
    digit digits
  + e
    e
    e+
    e-
    E
    E+
    E-


** YAML

*** Superset of JSON.

*** Uses indentation to group objects in collections.

*** Has an idea of identity and type information.


** OGDL
