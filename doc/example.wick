#!/usr/bin/env wick0

fn = {
  here (inputs, output) = {
    here (*args) = if (is (inputs, var) or length (i ^ (i <- args)) == length (i),
      {
        *(output <- (input <- args))
      },
      {
        error ('Missing arguments.')
      })
    }
  here (inputs, output, body) = {
    here (*args) = if (is (inputs, var) or length (i ^ (i <- args)) == length (i),
      {
        *{
          # Create lexical structure
          prev = (inputs <- args)
          last = for (stat, body,
            [
              prev = stat <- prev
            ]).prev
          res = *(ouput <- last)
        }.res
      },
      {
        error ('Missing arguments.')
      })
    }
  }

# Equivalently
do = fn (statements, last_stat, [
  last_stat = {}
  i = 0
  *while (statements[i] != nil, [
    last_stat = statements[i] <- last_stat
    i = i + 1
    ])
  ])

fib = fn ([n], a, [
  a = 0
  b = 1
  while (n != 0,
    [{
      a = b
      b = a + b
      n = n - 1
    }])
  ])

for = {
  here (pat, seq, body) =
    (common <- [pat, seq, body]).w
  here (pat, seq, body, end) =
    end & (common <- [pat, seq, body]).w
  common = [pat, seq, body] | {
    prev = {}
    w = while (seq[i] != nil, [
      prev = body <- (prev <- (pat <- seq[i]))
      ]).prev
    }
  }


unless = fn ([cond, body, alt] | {alt = {}}, if (!cond, body, alt))

# This doesn't work.
# The lack of known execution order (among other things) makes this an impractical way of implementing the top level.
# In the first place, the idea was 
main = fn (args, ret, [
  fib50 = fib (50)
  print (fib50)
  ret = 0
  ])
