#!/usr/bin/env wick0
print = fn([n] [] {
  import (sys)
  for ([i] n
    [
      sys.out.message (string.of (i))
    ])
  })

start -> {
  fib50 = fib (50)
  print (fib50)
  }

# primitives:


# application performs simple variable binding

assert (core.apply ({ .i = x } { x = 0 }).i == 0)

# assert never evaluates, since write to .i never triggers

assert (core.apply ({.i = x} {}).i == undefined)

assert (core.apply ({
  self = here
  n == 0 -> core.apply (self {.out = a})
  n != 0 -> core.apply (self {
    n = n - 1
    a = b
    b = a + b
    })
  } {
  a = 0
  b = 1
  n = 50
  } ) == fib (50))

syntax.prefix ('*' { core.apply (core.parent (here) .in) })

assert (core.apply ({
  n == 0 -> *{.out = a}
  n != 0 -> *{
    n = n - 1
    a = b
    b = a + b
    }
  } {
  a = 0
  b = 1
  n = 50
  } ) == fib (50))

fib = fn ([n] [out] {
  n = n
  a = 0
  b = 1
  here (
    n != 0 -> &(
      a <- b
      b <- a + b
      n <- n - 1
    )
    n == 0 -> out = a
  )})


So if we picture fibonacci, we basically have an initial setup transaction, which is initially fed into the reaction loop. The reaction loop is actually a transaction which is performing a duplicating unification with itself. The tricky part is describing the topology of this operation, since the duplicated yarn needs to repeat this process for an arbitrary amount. However, it also needs to stop.


fib = fn ([in] [out] {
  initial = {
    n = in
    a = 0
    b = 1
    }
  step = {
    a = b
    b = a + b
    n = n - 1
    }
  recur = {
    n == 0 -> {out = a}
    free n -> {recur (*step (here))}
    }
  recur (*initial)
  })

fn = ${
  $inputs
  $outputs
  $body
  here (args) -> here = outputs (*body (*inputs (here)))
  }

core.assert (fib (8) == 21)

--------------------------------------------------------------------------------


fn = {
  here (inputs output) = {
    res = output \ inputs
    here (*args) = if (is (inputs, var) or length (i ^ (i <- args)) == length (i)
      {
        *((inputs <- args)[res] & output)
      }
      {
        error ('Missing arguments.')
      })
    }
  here (inputs output body) = {
    prev = inputs
    # Create lexical structure
    last = for (stat body
      [
        prev = stat \ prev
      ]).prev
    here (*args) = if (is (inputs, var) or length (i ^ (i <- args)) == length (i)
      {
        *((inputs <- args)[last] & output)
      }
      {
        error ('Missing arguments.')
      })
    }
  }

# Verbose definition of do
# do = fn (statements res [
#   last_stat = {}
#   res = for (stat statements
#       {
#         last_stat = stat \ last_stat
#       }
#       {
#         *last_stat
#       })
#   ])

# Equivalently
do = fn (statements last_stat [
  last_stat = {}
  i = 0
  *while (statements[i] != nil [
    last_stat = statements[i] \ last_stat
    i = i + 1
    ])
  ])


fib = fn ([n] a [
  a = 0
  b = 1
  while (n != 0
    [{
      a = b
      b = a + b
      n = n - 1
    }])
  ])

for = {
  here (pat seq body) =
    (common <- [pat seq body]).w
  here (pat seq body end) =
    end & (common <- [pat seq body]).w
  common = [pat seq body] | {
    prev = {}
    w = while (seq[i] != nil [
      res = [pat, body] <- [seq[i], (body \ pat \ prev)]
      prev = res[body]
      ])
    }
  }


unless = fn ([cond body alt] | {alt = {}} if (!cond body alt))

# This doesn't work.
# The lack of known execution order (among other things) makes this an impractical way of implementing the top level.
# In the first place, the idea was 
main = fn (args ret [
  fib50 = fib (50)
  print (fib50)
  ret = 0
  ])
